{"version":3,"sources":["../../src/logging/logging.service.ts"],"sourcesContent":["import { Injectable, Logger } from '@nestjs/common';\nimport { PrismaService } from '../prisma/prisma.service';\nimport { Request } from 'express';\nimport { Prisma } from '@prisma/client';\n\n@Injectable()\nexport class LoggingService {\n  private readonly logger = new Logger(LoggingService.name);\n  private readonly APP_SOURCE = 'main-app';\n\n  constructor(private prisma: PrismaService) {}\n\n  private getChangedValues(oldData: any, newData: any): any {\n    const changes: any = {};\n    const allKeys = new Set([...Object.keys(oldData || {}), ...Object.keys(newData || {})]);\n\n    for (const key of allKeys) {\n      // Skip system fields\n      if (key === 'createdAt' || key === 'updatedAt' || key === 'created_at' || key === 'updated_at') {\n        continue;\n      }\n\n      const oldValue = oldData?.[key];\n      const newValue = newData?.[key];\n\n      // Handle arrays (like roles)\n      if (Array.isArray(oldValue) || Array.isArray(newValue)) {\n        const oldArray = Array.isArray(oldValue) ? oldValue : [];\n        const newArray = Array.isArray(newValue) ? newValue : [];\n        \n        // Compare arrays by their sorted stringified values to handle order differences\n        const oldArrayStr = JSON.stringify([...oldArray].sort());\n        const newArrayStr = JSON.stringify([...newArray].sort());\n        \n        if (oldArrayStr !== newArrayStr) {\n          changes[key] = newArray;\n        }\n      }\n      // Handle objects\n      else if (typeof oldValue === 'object' && oldValue !== null && \n               typeof newValue === 'object' && newValue !== null) {\n        if (JSON.stringify(oldValue) !== JSON.stringify(newValue)) {\n          changes[key] = newValue;\n        }\n      }\n      // Handle primitive values\n      else if (oldValue !== newValue) {\n        changes[key] = newValue;\n      }\n      // Handle deleted fields\n      else if (key in oldData && !(key in newData)) {\n        changes[key] = null;\n      }\n      // Handle new fields\n      else if (!(key in oldData) && key in newData) {\n        changes[key] = newValue;\n      }\n    }\n\n    return Object.keys(changes).length > 0 ? changes : undefined;\n  }\n\n  async logDatabaseAction(\n    table: string,\n    action: 'insert' | 'update' | 'delete',\n    recordId: string,\n    details: any,\n    operationDetails?: any,\n    userId?: string,\n  ) {\n    try {\n      let logDetails: any;\n\n      this.logger.debug('Logging action received:', {\n        table,\n        action,\n        recordId,\n        details,\n        operationDetails,\n        userId\n      });\n\n      switch (action) {\n        case 'insert':\n          logDetails = details;\n          break;\n        case 'update':\n          // For updates, we want to show all changed fields\n          logDetails = {};\n          const changes = this.getChangedValues(operationDetails, details);\n          if (changes) {\n            // Include all changed fields in the details\n            for (const key in changes) {\n              // Format array values as comma-separated strings\n              if (Array.isArray(changes[key])) {\n                logDetails[key] = changes[key].join(', ');\n              } else {\n                logDetails[key] = changes[key];\n              }\n            }\n          }\n          break;\n        case 'delete':\n          logDetails = operationDetails;\n          break;\n      }\n\n      if (logDetails && Object.keys(logDetails).length > 0) {\n        this.logger.debug(`Logging ${action} action for ${table} with ID ${recordId}`);\n        this.logger.debug('Details:', logDetails);\n        this.logger.debug('Operation Details:', operationDetails);\n\n        // Format the details as a string without curly braces\n        const formattedDetails = Object.entries(logDetails)\n          .map(([key, value]) => {\n            // Format field names\n            let formattedKey = key;\n            switch (key) {\n              case 'firstname':\n                formattedKey = 'FirstName';\n                break;\n              case 'lastname':\n                formattedKey = 'LastName';\n                break;\n              case 'preferred_language':\n                formattedKey = 'Language';\n                break;\n              case 'user_roles':\n                formattedKey = 'Roles';\n                break;\n              default:\n                // Convert snake_case to Title Case\n                formattedKey = key\n                  .split('_')\n                  .map(word => word.charAt(0).toUpperCase() + word.slice(1))\n                  .join(' ');\n            }\n            return `${formattedKey}: ${value}`;\n          })\n          .join(', ');\n\n        await this.prisma.database_logs.create({\n          data: {\n            table_name: table,\n            action: action,\n            record_id: recordId,\n            details: formattedDetails,\n            operation_details: operationDetails,\n            user_id: userId,\n            source: this.APP_SOURCE,\n          },\n        });\n      } else {\n        this.logger.debug(`No changes detected for ${action} action on ${table} with ID ${recordId}`);\n      }\n    } catch (error) {\n      this.logger.error(`Error logging database action: ${error.message}`);\n      this.logger.error('Error details:', error);\n    }\n  }\n\n  async trackUserAction(\n    userId: string,\n    sessionId: string,\n    pageVisited: string,\n    actionType: string,\n    actionData?: any,\n    source?: string\n  ) {\n    try {\n      // Verify that the session exists\n      const session = await this.prisma.user_sessions.findUnique({\n        where: {\n          session_id: sessionId\n        }\n      });\n\n      // If session doesn't exist, log error and return without tracking\n      if (!session) {\n        this.logger.warn(`Session ${sessionId} does not exist for user ${userId}, cannot track action`);\n        return;\n      }\n\n      // Track the action\n      await this.prisma.user_analytics.create({\n        data: {\n          user_id: userId,\n          session_id: sessionId,\n          page_visited: pageVisited,\n          action_type: actionType,\n          action_data: actionData || {},\n          source: source || this.APP_SOURCE,\n        },\n      });\n\n      this.logger.debug(\n        `Tracked action: ${actionType} by user ${userId} on page ${pageVisited} from source ${source || this.APP_SOURCE}`\n      );\n    } catch (error) {\n      this.logger.error(\n        `Error tracking user action: ${error.message}`,\n        error.stack\n      );\n      // Don't rethrow - analytics should never break the application\n    }\n  }\n\n  async createUserSession(userId: string, req: Request, sessionType: string, source?: string) {\n    try {\n      // Validate userId is present\n      if (!userId) {\n        this.logger.error('Invalid user ID provided for session creation');\n        throw new Error('User ID is required to create a session');\n      }\n      \n      const sourceValue = source || this.APP_SOURCE;\n      this.logger.debug(`Creating session for user ID: ${userId} with type: ${sessionType} and source: ${sourceValue}`);\n      \n      const userAgent = req.headers['user-agent'];\n      const ip = req.ip || req.socket.remoteAddress;\n      \n      // Parse user agent to get device, browser and OS info\n      let deviceType = 'unknown';\n      let browser = 'unknown';\n      let os = 'unknown';\n      \n      if (userAgent) {\n        // Simple parsing - in production, consider using a proper library like ua-parser-js\n        if (userAgent.includes('Mobile')) {\n          deviceType = 'mobile';\n        } else if (userAgent.includes('Tablet')) {\n          deviceType = 'tablet';\n        } else {\n          deviceType = 'desktop';\n        }\n        \n        // Crude browser detection\n        if (userAgent.includes('Chrome')) {\n          browser = 'Chrome';\n        } else if (userAgent.includes('Firefox')) {\n          browser = 'Firefox';\n        } else if (userAgent.includes('Safari')) {\n          browser = 'Safari';\n        } else if (userAgent.includes('Edge')) {\n          browser = 'Edge';\n        }\n        \n        // Crude OS detection\n        if (userAgent.includes('Windows')) {\n          os = 'Windows';\n        } else if (userAgent.includes('Mac')) {\n          os = 'MacOS';\n        } else if (userAgent.includes('Linux')) {\n          os = 'Linux';\n        } else if (userAgent.includes('Android')) {\n          os = 'Android';\n        } else if (userAgent.includes('iOS')) {\n          os = 'iOS';\n        }\n      }\n      \n      // Check if the user already has an active session\n      const existingSession = await this.prisma.user_sessions.findFirst({\n        where: {\n          user_id: userId,\n          is_active: true\n        }\n      });\n      \n      if (existingSession) {\n        this.logger.debug(`User ${userId} already has an active session ${existingSession.session_id}, reusing it`);\n        return {\n          sessionId: existingSession.session_id,\n          loginTime: existingSession.login_time\n        };\n      }\n      \n      // Create the session with proper user relation\n      const sessionData = {\n        user_id: userId,\n        ip_address: ip,\n        device_type: deviceType,\n        browser,\n        os,\n        user_agent: userAgent,\n        is_active: true,\n        session_type: sessionType,\n        source: sourceValue,\n      };\n      \n      this.logger.debug(`Creating new session with data:`, sessionData);\n      \n      try {\n        const session = await this.prisma.user_sessions.create({\n          data: sessionData,\n        });\n        \n        this.logger.debug(`Successfully created session ${session.session_id} for user ${userId} with source ${sourceValue}`);\n        \n        return {\n          sessionId: session.session_id,\n          loginTime: session.login_time\n        };\n      } catch (dbError) {\n        this.logger.error(`Database error creating session: ${dbError.message}`, dbError.stack);\n        // Create simplified session data if the first attempt failed\n        const simplifiedSession = await this.prisma.user_sessions.create({\n          data: {\n            user_id: userId,\n            session_type: sessionType,\n            source: sourceValue,\n          },\n        });\n        \n        this.logger.debug(`Created simplified session ${simplifiedSession.session_id} as fallback with source ${sourceValue}`);\n        \n        return {\n          sessionId: simplifiedSession.session_id,\n          loginTime: simplifiedSession.login_time\n        };\n      }\n    } catch (error) {\n      this.logger.error(`Error creating user session: ${error.message}`, error.stack);\n      throw error;\n    }\n  }\n\n  async endUserSession(userId: string, sessionId: string) {\n    try {\n      const session = await this.prisma.user_sessions.findFirst({\n        where: {\n          session_id: sessionId,\n          user_id: userId,\n        },\n      });\n      \n      if (session) {\n        // Calculate session duration in seconds\n        const loginTime = new Date(session.login_time);\n        const logoutTime = new Date();\n        const durationMs = logoutTime.getTime() - loginTime.getTime();\n        const durationSec = Math.floor(durationMs / 1000);\n        \n        await this.prisma.user_sessions.update({\n          where: {\n            session_id: sessionId,\n          },\n          data: {\n            is_active: false,\n            logout_time: logoutTime,\n            duration: durationSec,\n          },\n        });\n        \n        return true;\n      }\n      \n      return false;\n    } catch (error) {\n      this.logger.error(`Error ending user session: ${error.message}`);\n      throw error;\n    }\n  }\n} "],"names":["LoggingService","getChangedValues","oldData","newData","changes","allKeys","Set","Object","keys","key","oldValue","newValue","Array","isArray","oldArray","newArray","oldArrayStr","JSON","stringify","sort","newArrayStr","length","undefined","logDatabaseAction","table","action","recordId","details","operationDetails","userId","logDetails","logger","debug","join","formattedDetails","entries","map","value","formattedKey","split","word","charAt","toUpperCase","slice","prisma","database_logs","create","data","table_name","record_id","operation_details","user_id","source","APP_SOURCE","error","message","trackUserAction","sessionId","pageVisited","actionType","actionData","session","user_sessions","findUnique","where","session_id","warn","user_analytics","page_visited","action_type","action_data","stack","createUserSession","req","sessionType","Error","sourceValue","userAgent","headers","ip","socket","remoteAddress","deviceType","browser","os","includes","existingSession","findFirst","is_active","loginTime","login_time","sessionData","ip_address","device_type","user_agent","session_type","dbError","simplifiedSession","endUserSession","Date","logoutTime","durationMs","getTime","durationSec","Math","floor","update","logout_time","duration","constructor","Logger","name"],"mappings":"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"}