{"version":3,"sources":["../../src/auth/auth.service.ts"],"sourcesContent":["import {\n  Injectable,\n  UnauthorizedException,\n  BadRequestException,\n  Logger,\n  NotFoundException,\n} from '@nestjs/common';\nimport { JwtService } from '@nestjs/jwt';\nimport { ConfigService } from '@nestjs/config';\nimport { PrismaService } from '../prisma/prisma.service';\nimport * as bcrypt from 'bcrypt';\nimport * as crypto from 'crypto';\n\n@Injectable()\nexport class AuthService {\n  private readonly logger = new Logger(AuthService.name);\n\n  constructor(\n    private prisma: PrismaService,\n    private jwtService: JwtService,\n    private configService: ConfigService,\n  ) {}\n\n  async register(\n    email: string, \n    password: string, \n    name: string,\n    profileData?: {\n      title?: string;\n      gender?: string;\n      firstname?: string;\n      lastname?: string;\n      lastname2?: string;\n      dob?: Date;\n    }\n  ) {\n    this.logger.log(`Registering user with email: ${email}, name: ${name}`);\n\n    // Check if user already exists\n    const existingUser = await this.prisma.users.findUnique({\n      where: { email },\n      select: {\n        email: true,\n        user_id: true,\n        username: true,\n      },\n    });\n\n    if (existingUser) {\n      throw new BadRequestException('Email already in use');\n    }\n\n    // Hash password\n    const hashedPassword = await bcrypt.hash(password, 10);\n    \n    // Generate a username from email\n    const usernameBase = email.split('@')[0];\n    let username = usernameBase;\n    let counter = 1;\n    \n    // Check if username exists and generate a new one if needed\n    while (\n      await this.prisma.users.findFirst({\n        where: {\n          username: {\n            equals: username,\n            mode: 'insensitive',\n          },\n        },\n        select: {\n          username: true,\n        },\n      })\n    ) {\n      username = `${usernameBase}${counter}`;\n      counter++;\n    }\n\n    try {\n      // Create user\n      const user = await this.prisma.users.create({\n        data: {\n          email,\n          username,\n          password_hash: hashedPassword,\n          title: profileData?.title,\n          gender: profileData?.gender,\n          firstname: profileData?.firstname,\n          lastname: profileData?.lastname,\n          lastname2: profileData?.lastname2,\n          dob: profileData?.dob,\n        },\n        select: {\n          user_id: true,\n          email: true,\n          username: true,\n        },\n      });\n\n      // Generate verification token\n      const verificationToken = crypto.randomBytes(32).toString('hex');\n      \n      // Set token to expire in 24 hours\n      const expiresAt = new Date();\n      expiresAt.setHours(expiresAt.getHours() + 24);\n      \n      // Store token using Prisma model\n      await this.prisma.verification_tokens.create({\n        data: {\n          user_id: user.user_id,\n          token: verificationToken,\n          type: 'email_verification',\n          expires_at: expiresAt,\n        },\n      });\n\n      this.logger.log(\n        `User registered with ID: ${user.user_id}, verification token generated`,\n      );\n\n      // Return the verification token for development/testing\n      // In production, you would send this by email and not return it\n      return {\n        userId: user.user_id,\n        username: user.username,\n        message: 'User registered successfully. Please verify your email.',\n        verificationToken, // Remove this in production\n      };\n    } catch (error) {\n      this.logger.error('Error creating user:', error);\n      \n      const errorMessage = error instanceof Error ? error.message : String(error);\n      throw new BadRequestException('Failed to create user: ' + errorMessage);\n    }\n  }\n\n  async login(email: string, password: string) {\n    this.logger.log(`Login attempt for user with email: ${email}`);\n\n    const user = await this.prisma.users.findUnique({\n      where: { email },\n      select: {\n        user_id: true,\n        email: true,\n        username: true,\n        password_hash: true,\n      },\n    });\n\n    if (!user) {\n      throw new UnauthorizedException('Invalid credentials');\n    }\n\n    const isPasswordValid = await bcrypt.compare(\n      password,\n      user.password_hash || '',\n    );\n\n    if (!isPasswordValid) {\n      throw new UnauthorizedException('Invalid credentials');\n    }\n\n    // Check if user's email is verified\n    const isVerified = await this.isEmailVerified(user.user_id);\n    if (!isVerified) {\n      throw new UnauthorizedException(\n        'Email not verified. Please verify your email before logging in.',\n      );\n    }\n\n    const payload = {\n      sub: user.user_id,\n      email: user.email,\n    };\n\n    return {\n      accessToken: this.jwtService.sign(payload),\n      user: {\n        id: user.user_id,\n        email: user.email,\n        username: user.username,\n      },\n    };\n  }\n\n  async verifyEmail(token: string) {\n    this.logger.log(`Verifying email with token: ${token}`);\n    \n    // Find verification token in the database\n    const verificationToken = await this.prisma.verification_tokens.findUnique({\n      where: { token },\n    });\n    \n    if (!verificationToken) {\n      throw new NotFoundException('Invalid verification token');\n    }\n\n    // Check if token has expired\n    if (verificationToken.expires_at < new Date()) {\n      // Delete the expired token\n      await this.prisma.verification_tokens.delete({\n        where: { token_id: verificationToken.token_id },\n      });\n      throw new BadRequestException('Verification token has expired');\n    }\n\n    // Mark token as verified by changing its type\n    await this.prisma.verification_tokens.update({\n      where: { token_id: verificationToken.token_id },\n      data: { type: 'email_verified' },\n    });\n\n    return {\n      message: 'Email verified successfully. You can now log in.',\n      userId: verificationToken.user_id,\n    };\n  }\n\n  // Helper method to check if a user's email is verified\n  private async isEmailVerified(userId: string): Promise<boolean> {\n    const verifiedToken = await this.prisma.verification_tokens.findFirst({\n      where: {\n        user_id: userId,\n        type: 'email_verified',\n      },\n    });\n    \n    return !!verifiedToken;\n  }\n\n  // Method for OAuth authentication\n  validateOAuthUser(email: string, name: string, provider: string) {\n    // Create a simple username from the email\n    const username = email.split('@')[0];\n    \n    // Return the user structure without database operations\n    // In a real implementation, this would find or create the user\n    return {\n      accessToken: this.jwtService.sign({\n        sub: 'temp-user-id',\n        email,\n        provider,\n      }),\n      user: {\n        id: 'temp-user-id',\n        email,\n        username,\n      },\n    };\n  }\n\n  async requestPasswordReset(email: string) {\n    this.logger.log(`Password reset requested for email: ${email}`);\n\n    const user = await this.prisma.users.findUnique({\n      where: { email },\n      select: {\n        user_id: true,\n        email: true,\n      },\n    });\n\n    if (!user) {\n      // For security reasons, we still return success even if the email doesn't exist\n      return {\n        message: 'If the email exists, a password reset link will be sent.',\n      };\n    }\n\n    // Generate reset token\n    const resetToken = crypto.randomBytes(32).toString('hex');\n    \n    // Set token to expire in 1 hour\n    const expiresAt = new Date();\n    expiresAt.setHours(expiresAt.getHours() + 1);\n    \n    // Store reset token\n    await this.prisma.password_reset_tokens.create({\n      data: {\n        user_id: user.user_id,\n        token: resetToken,\n        expires_at: expiresAt,\n      },\n    });\n\n    // In production, send this via email instead of returning it\n    return {\n      message: 'Password reset instructions have been sent to your email.',\n      resetToken, // Remove this in production\n    };\n  }\n\n  async resetPassword(token: string, newPassword: string) {\n    this.logger.log('Processing password reset request');\n\n    const resetToken = await this.prisma.password_reset_tokens.findFirst({\n      where: {\n        token,\n        used: false,\n        expires_at: {\n          gt: new Date(),\n        },\n      },\n      include: {\n        users: true,\n      },\n    });\n\n    if (!resetToken) {\n      throw new BadRequestException('Invalid or expired reset token');\n    }\n\n    // Hash the new password\n    const hashedPassword = await bcrypt.hash(newPassword, 10);\n\n    // Update the user's password and mark token as used in a transaction\n    await this.prisma.$transaction([\n      // Update password\n      this.prisma.users.update({\n        where: { user_id: resetToken.user_id },\n        data: { password_hash: hashedPassword },\n      }),\n      // Mark token as used\n      this.prisma.password_reset_tokens.update({\n        where: { token_id: resetToken.token_id },\n        data: { used: true },\n      }),\n    ]);\n\n    return {\n      message: 'Password has been reset successfully. You can now log in with your new password.',\n    };\n  }\n} "],"names":["AuthService","register","email","password","name","profileData","logger","log","existingUser","prisma","users","findUnique","where","select","user_id","username","BadRequestException","hashedPassword","bcrypt","hash","usernameBase","split","counter","findFirst","equals","mode","user","create","data","password_hash","title","gender","firstname","lastname","lastname2","dob","verificationToken","crypto","randomBytes","toString","expiresAt","Date","setHours","getHours","verification_tokens","token","type","expires_at","userId","message","error","errorMessage","Error","String","login","UnauthorizedException","isPasswordValid","compare","isVerified","isEmailVerified","payload","sub","accessToken","jwtService","sign","id","verifyEmail","NotFoundException","delete","token_id","update","verifiedToken","validateOAuthUser","provider","requestPasswordReset","resetToken","password_reset_tokens","resetPassword","newPassword","used","gt","include","$transaction","constructor","configService","Logger"],"mappings":"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"}