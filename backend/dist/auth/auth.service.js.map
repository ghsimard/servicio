{"version":3,"sources":["../../src/auth/auth.service.ts"],"sourcesContent":["import {\n  Injectable,\n  UnauthorizedException,\n  BadRequestException,\n  Logger,\n  NotFoundException,\n} from '@nestjs/common';\nimport { JwtService } from '@nestjs/jwt';\nimport { ConfigService } from '@nestjs/config';\nimport { PrismaService } from '../prisma/prisma.service';\nimport * as bcrypt from 'bcrypt';\nimport * as crypto from 'crypto';\n\n@Injectable()\nexport class AuthService {\n  private readonly logger = new Logger(AuthService.name);\n\n  constructor(\n    private prisma: PrismaService,\n    private jwtService: JwtService,\n    private configService: ConfigService,\n  ) {}\n\n  async register(\n    email: string, \n    password: string, \n    name: string,\n    profileData?: {\n      title?: string;\n      gender?: string;\n      firstname?: string;\n      lastname?: string;\n      lastname2?: string;\n      dob?: Date;\n    }\n  ) {\n    this.logger.log(`Registering user with email: ${email}, name: ${name}`);\n\n    // Check if user already exists\n    const existingUser = await this.prisma.user.findUnique({\n      where: { email },\n      select: {\n        email: true,\n        user_id: true,\n        username: true,\n      },\n    });\n\n    if (existingUser) {\n      throw new BadRequestException('Email already in use');\n    }\n\n    // Hash password\n    const hashedPassword = await bcrypt.hash(password, 10);\n    \n    // Generate a username from email\n    const usernameBase = email.split('@')[0];\n    let username = usernameBase;\n    let counter = 1;\n    \n    // Check if username exists and generate a new one if needed\n    while (\n      await this.prisma.user.findFirst({\n        where: {\n          username: {\n            equals: username,\n            mode: 'insensitive',\n          },\n        },\n        select: {\n          username: true,\n        },\n      })\n    ) {\n      username = `${usernameBase}${counter}`;\n      counter++;\n    }\n\n    try {\n      // Create user\n      const user = await this.prisma.user.create({\n        data: {\n          email,\n          username,\n          password_hash: hashedPassword,\n          title: profileData?.title,\n          gender: profileData?.gender,\n          firstname: profileData?.firstname,\n          lastname: profileData?.lastname,\n          lastname2: profileData?.lastname2,\n          dob: profileData?.dob,\n        },\n        select: {\n          user_id: true,\n          email: true,\n          username: true,\n        },\n      });\n\n      // Generate verification token\n      const verificationToken = crypto.randomBytes(32).toString('hex');\n      \n      // Set token to expire in 24 hours\n      const expiresAt = new Date();\n      expiresAt.setHours(expiresAt.getHours() + 24);\n      \n      // Store token using Prisma model\n      await this.prisma.verification_tokens.create({\n        data: {\n          user_id: user.user_id,\n          token: verificationToken,\n          type: 'email_verification',\n          expires_at: expiresAt,\n        },\n      });\n\n      this.logger.log(\n        `User registered with ID: ${user.user_id}, verification token generated`,\n      );\n\n      // Return the verification token for development/testing\n      // In production, you would send this by email and not return it\n      return {\n        userId: user.user_id,\n        username: user.username,\n        message: 'User registered successfully. Please verify your email.',\n        verificationToken, // Remove this in production\n      };\n    } catch (error) {\n      this.logger.error('Error creating user:', error);\n      \n      const errorMessage = error instanceof Error ? error.message : String(error);\n      throw new BadRequestException('Failed to create user: ' + errorMessage);\n    }\n  }\n\n  async login(email: string, password: string) {\n    this.logger.log(`Login attempt for user with email: ${email}`);\n\n    const user = await this.prisma.user.findUnique({\n      where: { email },\n      select: {\n        user_id: true,\n        email: true,\n        username: true,\n        password_hash: true,\n      },\n    });\n\n    if (!user) {\n      this.logger.error(`User not found: ${email}`);\n      throw new UnauthorizedException('Invalid credentials');\n    }\n\n    this.logger.log(`User found: ${user.user_id}, hash: ${user.password_hash ? 'exists' : 'missing'}`);\n\n    try {\n      // Special bypass for debug login\n      let isPasswordValid = false;\n      \n      if (password === 'BYPASS_PASSWORD') {\n        this.logger.log('Using debug password bypass');\n        isPasswordValid = true;\n      } else {\n        isPasswordValid = await bcrypt.compare(\n          password,\n          user.password_hash || '',\n        );\n        this.logger.log(`Password validation result: ${isPasswordValid}`);\n      }\n\n      if (!isPasswordValid) {\n        this.logger.error(`Invalid password for user: ${user.user_id}`);\n        throw new UnauthorizedException('Invalid credentials');\n      }\n\n      // TEMPORARILY BYPASS EMAIL VERIFICATION FOR TESTING\n      // const isVerified = await this.isEmailVerified(user.user_id);\n      // if (!isVerified) {\n      //   throw new UnauthorizedException(\n      //     'Email not verified. Please verify your email before logging in.',\n      //   );\n      // }\n\n      const payload = {\n        sub: user.user_id,\n        email: user.email,\n      };\n\n      return {\n        accessToken: this.jwtService.sign(payload),\n        user: {\n          id: user.user_id,\n          email: user.email,\n          username: user.username,\n        },\n      };\n    } catch (error) {\n      this.logger.error(`Error during password validation: ${error.message}`);\n      throw new UnauthorizedException('Invalid credentials');\n    }\n  }\n\n  async verifyEmail(token: string) {\n    this.logger.log(`Verifying email with token: ${token}`);\n    \n    // Find verification token in the database\n    const verificationToken = await this.prisma.verification_tokens.findUnique({\n      where: { token },\n    });\n    \n    if (!verificationToken) {\n      throw new NotFoundException('Invalid verification token');\n    }\n\n    // Check if token has expired\n    if (verificationToken.expires_at < new Date()) {\n      // Delete the expired token\n      await this.prisma.verification_tokens.delete({\n        where: { token },\n      });\n      throw new BadRequestException('Verification token has expired');\n    }\n\n    // Get the user associated with the token\n    const user = await this.prisma.user.findUnique({\n      where: { user_id: verificationToken.user_id },\n    });\n\n    if (!user) {\n      throw new NotFoundException('User not found');\n    }\n\n    // Mark the user as verified by updating the token type\n    await this.prisma.verification_tokens.update({\n      where: { token },\n      data: {\n        type: 'verified',\n      },\n    });\n\n    return {\n      message: 'Email verified successfully',\n      userId: user.user_id,\n    };\n  }\n\n  private async isEmailVerified(userId: string): Promise<boolean> {\n    const token = await this.prisma.verification_tokens.findFirst({\n      where: {\n        user_id: userId,\n        type: 'verified',\n      },\n    });\n    return !!token;\n  }\n\n  validateOAuthUser(email: string, name: string, provider: string) {\n    // Handle OAuth authentication\n    // This would typically check if the user exists,\n    // create them if they don't, and generate a JWT token\n    \n    return {\n      email,\n      name,\n      provider,\n    };\n  }\n\n  async requestPasswordReset(email: string) {\n    const user = await this.prisma.user.findUnique({\n      where: { email },\n      select: {\n        user_id: true,\n        email: true,\n      },\n    });\n\n    if (!user) {\n      throw new NotFoundException('User not found');\n    }\n\n    // Generate reset token\n    const resetToken = crypto.randomBytes(32).toString('hex');\n    \n    // Set token to expire in 1 hour\n    const expiresAt = new Date();\n    expiresAt.setHours(expiresAt.getHours() + 1);\n    \n    // Store token in database \n    // NOTE: This assumes you have a password_reset_tokens table/model\n    // You may need to adjust this code based on your actual schema\n    await this.prisma.verification_tokens.create({\n      data: {\n        user_id: user.user_id,\n        token: resetToken,\n        type: 'password_reset',\n        expires_at: expiresAt,\n      },\n    });\n    \n    this.logger.log(`Password reset requested for user ${user.user_id}`);\n\n    // Return the reset token for development/testing\n    // In production, you would send this by email and not return it\n    return {\n      message: 'Password reset token generated',\n      resetToken, // Remove this in production\n    };\n  }\n\n  async resetPassword(token: string, newPassword: string) {\n    // Find reset token in the database\n    const resetToken = await this.prisma.verification_tokens.findFirst({\n      where: {\n        token,\n        type: 'password_reset',\n      },\n    });\n    \n    if (!resetToken) {\n      throw new NotFoundException('Invalid reset token');\n    }\n    \n    // Check if token has expired\n    if (resetToken.expires_at < new Date()) {\n      // Delete the expired token\n      await this.prisma.verification_tokens.delete({\n        where: { token_id: resetToken.token_id },\n      });\n      throw new BadRequestException('Reset token has expired');\n    }\n\n    // Hash the new password\n    const hashedPassword = await bcrypt.hash(newPassword, 10);\n    \n    // Update user password and mark token as used - transaction to ensure both operations succeed or fail together\n    await this.prisma.$transaction([\n      this.prisma.user.update({\n        where: { user_id: resetToken.user_id },\n        data: { password_hash: hashedPassword },\n      }),\n      this.prisma.verification_tokens.update({\n        where: { token_id: resetToken.token_id },\n        data: { type: 'used' },\n      }),\n    ]);\n    \n    this.logger.log(`Password reset for user ${resetToken.user_id}`);\n    \n    return {\n      message: 'Password reset successful',\n    };\n  }\n} "],"names":["AuthService","register","email","password","name","profileData","logger","log","existingUser","prisma","user","findUnique","where","select","user_id","username","BadRequestException","hashedPassword","bcrypt","hash","usernameBase","split","counter","findFirst","equals","mode","create","data","password_hash","title","gender","firstname","lastname","lastname2","dob","verificationToken","crypto","randomBytes","toString","expiresAt","Date","setHours","getHours","verification_tokens","token","type","expires_at","userId","message","error","errorMessage","Error","String","login","UnauthorizedException","isPasswordValid","compare","payload","sub","accessToken","jwtService","sign","id","verifyEmail","NotFoundException","delete","update","isEmailVerified","validateOAuthUser","provider","requestPasswordReset","resetToken","resetPassword","newPassword","token_id","$transaction","constructor","configService","Logger"],"mappings":"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"}